---
layout: page
title: Первый взгляд на Akka 2.0
author: Василий Ременюк
---
<div class="post">
	<p>
		Через несколько месяцев выходит major-релиз <a href="akka.io"><b>Akka</b></a>. <a href="http://twitter.com/#!/viktorklang">Виктор Клэнг</a>, и <a href="http://typesafe.com/">компания</a>, готовят нам большой сюрприз, к которому надо начинать готовиться уже сейчас. 			
	</p>
	<p>
		Те, кто с Akka уже давно (больше года), помнят сложности с миграцией, при переходе с версии 0.6 на 0.7, и, далее, на 0.8 (когда была введена концепция <i>ActorRef</i>, призванная отделить API актера от реализации (обрабатывающей), и, таким образом, сделать актеры более близкими к их прообразу в Erlang). Готовьтесь, друзья - изменения в <a href="https://github.com/jboner/akka"><b>Akka 2.0</b></a> носят характер революции.	
	</p>
	<p>
		Итак, по порядку:
	</p> 	
	<ol>
		<li>
		В Akka 2.0 больше нет такой концепции (по крайней мере, в рамках API), как <i>Remote Actor</i> и <i>Remote Server</i> (к слову, модуль akka-remote теперь тоже не существует). На смену им пришли кластеризованные актеры (<i>ClusterActorRef</i>) и кластера (<i>Cluster</i> и <i>Node</i> a la node’ы в Erlang). По умолчанию, если узел, на котором запускается актер, является частью кластера, он автоматически реплицируется на все другие узлы кластера (это происходит в рамках нового, управляемого процесса deployment’a). Когда вы отправляете кластеризованному актеру сообщение, роутер определяет, какому физическому актеру в рамках кластера будет перенаправлено сообщение (к примеру, если на “домашнем” узле памяти остается слишком мало, сообщение будет отправлено на ближайший удаленный узел). Таким образом, основная схема работы с кластеризованными актерами, на сегодняшний день, предполагает работу в духе computation grid (когда все актеры равны, обладают одинаковыми данными, и любой из них может быть выбран для вычислений);			
		</li>
		<ul>
			<li>
			По умолчанию, сообщение будет обработано только одним актером из кластера. Кроме этого, вы можете послать broadcast сообщение, которое будет доставлено всем актерам. На данный момент (по непонятным причинам) для массовой рассылки поддерживается только режим fire-forget(метод "!") - получения future’a ответа пока не поддерживается;			
			</li>
			<li>
			В API (пока) нет простого способа работы с конкретными актерами на удаленных узлах. Если, к примеру, у вас есть распределенный кэш (одна уникальная часть на каждом узле/JVM), и вы хотите работать с ним с помощью актеров, очевидного способа обратиться к конкретному актеру нет (вообще, складывается впечатление, что кластеризованными актерами пока хорошо поддерживается только работы в режиме реплицированных данных);			
			</li>
			<li>
			Есть базовая поддержка работы с кластером (базируется на <i>Apache ZooKeeper</i>) - вы можете отслеживать, когда в кластере появляются новые узлы и инициализируются реплики актера, устанавливать “барьеры” (что-то вроде распределенной версии CountDownLatch) и мн. другое;
			</li>
			<li>
			Хотя это и не является непосредственной частью <i>Akka 2.0</i>, появился очень удобный <a href="https://github.com/typesafehub/sbt-multi-jvm">плагин для sbt</a>, позволяющий тестировать распределенные системы (кластера) на одной машине, запуская “форки” JVM, исполняя на них тесты, и собирая логи. По умолчанию плагин поддерживает только scalatest, но есть сторонний <a href="https://github.com/remeniuk/sbt-multi-jvm">"форк" с поддержкой specs2</a>;
			</li>
		</ul>
		<li>
		На смену концепциям ID и UUID , пришла более очевидная концепция адреса актера (address) и уникального идентификатора в рамках кластера;
		</li>
		<li>
		Достаточно сильно изменился API реестра актеров (<i>ActorRegistry</i>). Актера теперь модно получить только по адресу или уникальному идентификатору (ранее актера можно было также получить по типу);
		</li>
		<li>
		Supervisor больше не стартует актеров, за которыми он наблюдает, и не останавливает актеров, когда прекращает работу сам. Теперь пользователь сам должен стартовать всех актеров, и передавать supervisor’у инициированные объекты;
		</li>
		<li>
		Больше нет блокирующего способа обращения к актеру с помощью метода “!!”. В Akka 2.0 актеру можно посать one-way сообщение (метод “!”) или получить <i>Future</i> ответа (метод “?”, аналог прошлого “!!!”). Работа с <i>Future</i>, к слову, самая удобная (и идиоматичная, с точки зрения функционального программирования) среди всех существующих библиотек;
		</li>
		<li>
		Многие методы переименованы в соответствие с Scala Style Guide’ом (в частности, популярный метод <i>ActorRef#reply_?</i> переименован в <i>ActorRef#tryReply</i>);
		</li>		
	</ol>
	<br/>
	<p>
	Это далеко не полный список изменений - только те, что сразу бросаются в глаза (когда проект отказывается компилироваться, при переходе на новые версии библиотек). Многие вещи, которые раньше необходимо было ush реализовывать самому (поддержка node’ов и кластеров, по аналогии с Erlang/OTP), теперь входит в стандартную поставку. Умное распределение работы по однотипным актерам в рамках кластера также значительно упрощает работу (хотя, идеологически, достаточно сильно отличается от предыдущего решения). Таким образом, если вы начинаете проект на <a href="https://github.com/jboner/akka">Akka 2.0</a> с нуля, вам придется делать намного меньше черновой работы. Если же вы мигрируете большой существующий проект с Akka 1.x, процесс может быть достаточно сложным, т.к. изменения в <a href="https://github.com/jboner/akka">версии 2.0</a> носят не количественный характер, а концептуальный (вам, скорее всего, придется отказаться о своих решений в пользу аналогичных, входящих в Akka, и переписать ощутимое количество кода). Поэтому, всем, кто использует Akka очень советую не откладывать знакомство с новей версией фреймворка, и уже сейчас поэкспериментировать с <a href="https://github.com/jboner/akka">2.0-SNAPSHOT</a> на одном из хобби-проектов. 
	</p>
</div>